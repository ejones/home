#! /usr/bin/env python
"""
Development script that runs setup.py with given arguments and then drops right
into a debugger for some file. Sets up pdb so that restarting it re-runs the
setup script.

The debugger has custom commands to remember run statements and re-run them.
"""
import pdb, bdb, sys, os, subprocess, json

def main():
    dstag = os.getenv('DEV_SHELL_TAG')
    if not dstag:
        supervise()
    else:
        interact(dstag)

def supervise():
    dbg = pdb.Pdb()
    
    sys.argv[0] = 'setup.py'
    while True:
        g = {}
        execfile('setup.py', g)
        if 'main' in g:
            g['main']()
        ccode = subprocess.Popen([os.path.abspath(__file__)],
                    env = dict(os.environ,
                        DEV_SHELL_TAG = os.path.abspath('setup.py'))).wait()
        if ccode != 3:
            break

def interact(dstag):
    dbg = Pdb(tag = dstag)
    try:
        try:
            dbg._user_requested_quit = 0
            dbg.run('')
        except (bdb.BdbQuit, pdb.Restart):
            raise
        except:
            import traceback
            traceback.print_exc()
            dbg.reset()
            dbg.interaction(None, sys.exc_info()[2])
        if not dbg._user_requested_quit:
            print 'The program ended and will be restarted'
            sys.exit(3)
    except pdb.Restart:
        print 'Restart requested...'
        sys.exit(3)

class Pdb(pdb.Pdb):
    def __init__(self, *args, **kwargs):
        self._running_memory = 0
        self._is_recalling = 0

        parent = kwargs.pop('parent', None)
        if not parent:
            tag = kwargs.pop('tag')

            assert os.path.sep != ':' # bleh.
            # we store remembered commands in plaintext, one per line, in the file
            # ~/.pydevshell/<argv>
            self.storepath = os.path.join(os.path.expanduser('~'), '.pydevshell',
                                                tag.replace(os.path.sep, ':'))


            self.memory = (
                os.path.isfile(self.storepath) and
                    open(self.storepath).readlines()
                or [])
        else:
            self.storepath = parent.storepath
            self.memory = parent.memory

        pdb.Pdb.__init__(self, *args, **kwargs)
            

    def runmemory(self, rng = None):
        if rng is None:
            rng = slice(None)
        self._running_memory = rng
        self.run('')

    def getstore(self, mode):
        if not os.path.isdir(os.path.dirname(self.storepath)):
            os.makedirs(os.path.dirname(self.storepath))
        return open(self.storepath, mode)

    # adapted from Pdb to inject memory if that's been requested
    def interaction(self, frame, traceback):
        self.setup(frame, traceback)
        if self._running_memory:
            self.do_mrecall(self._running_memory)
        else:
            self.print_stack_entry(self.stack[self.curindex])
        self.cmdloop()
        self.forget()

    # HACK: provide the last last command 
    def onecmd(self, line):
        self.last_lastcmd = self.lastcmd
        return pdb.Pdb.onecmd(self, line)

    def parse_range(self, arg):
        line1, sep, line2 = arg.partition(',')
        if not (line1 or line2):
            # whole thing
            return slice(None)
        try:
            if not sep:
                line2 = line1
            # range
            start, end = None, None
            if line1:
                start = int(line1)
                if start > 0:
                    start -= 1 # line numbers start at one
                # commands depend on a positive start
                if start < 0:
                    start = len(self.memory) + start
            if line2:
                # -1 for line numbering, +1 for inclusive end 
                end = int(line2)
                if end == -1:
                    end = None
                elif end < -1:
                    end += 1
            return slice(start, end)
        except ValueError:
            print >>self.stdout, arg, 'is not a valid line range'

    def help_madd(self):
        print >>self.stdout, """\
ma(dd) [cmd]
Add the last command to the remembered commands for this invocation.
If [cmd] is provided, run it and then add it.\
"""

    help_ma = help_madd

    def do_madd(self, arg):
        if arg:
            self.onecmd(arg)
            cmd = arg + '\n'
        else:
            cmd = self.last_lastcmd + '\n'
        self.memory.append(cmd)
        self.getstore('a').write(cmd)

    do_ma = do_madd

    def help_mrecall(self):
        print >>self.stdout, """\
mr(ecall) [line1[,[line2]]]
Run the recalled commands from memory. Unlike a calculator this doesn't remove
them.\
"""

    help_mr = help_mrecall

    @property
    def recall_prompt(self):
        return self.prompt.replace('(', '[').replace(')', ']')

    def do_mrecall(self, arg):
        self._is_recalling = rng = arg if isinstance(arg, slice) else self.parse_range(arg)
        while self._is_recalling and (rng.start or 0) < len(self.memory):
            cmd = self.memory[rng.start or 0]
            print >>self.stdout, self.recall_prompt.rstrip(), cmd,
            self._is_recalling = rng = slice((rng.start or 0) + 1, rng.stop)
            self.onecmd(cmd)
            rng = self._is_recalling
        self._is_recalling = 0

    do_mr = do_mrecall

    def help_mclear(self):
        print >>self.stdout, """\
mc(lear) [line1[,[line2]]]
Clear memory entries, optionally on a line or range.\
"""

    help_mc = help_mclear

    def do_mclear(self, arg):
        rng = self.parse_range(arg)
        del self.memory[rng]
        if os.path.isfile(self.storepath):
            os.unlink(self.storepath)

    do_mc = do_mclear

    def help_mlist(self):
        print >>self.stdout, """\
ml(ist) [line1[,[line2]]]
List the remembered commands, optionally on a line or range.\
"""
    
    help_ml = help_mlist

    def do_mlist(self, arg):
        rng = self.parse_range(arg)
        for i, cmd in enumerate(self.memory[rng]):
            print >>self.stdout, (rng.start or 0) + i + 1, ' ', cmd, # cmds end in newlines

    do_ml = do_mlist

    # HACK: override to inject our own debugger
    # adapted from pdb.py
    def do_debug(self, arg):
        sys.settrace(None)
        globals = self.curframe.f_globals
        locals = self.curframe_locals
        p = self.__class__(self.completekey, self.stdin, self.stdout, parent=self)
        p.prompt = "(%s) " % self.prompt.strip()
        p.lastcmd = self.lastcmd
        print >>self.stdout, "ENTERING RECURSIVE DEBUGGER"
        if self._is_recalling:
            rng = self._is_recalling
            sys.call_tracing(p.runmemory, (slice(rng.start, rng.stop),))
        else:
            sys.call_tracing(p.run, (arg, globals, locals))
        print >>self.stdout, "LEAVING RECURSIVE DEBUGGER"
        sys.settrace(self.trace_dispatch)
        self._is_recalling = p._is_recalling
        self.lastcmd = p.lastcmd

if __name__ == '__main__':
    main()
